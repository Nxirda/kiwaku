<!------------------------------------------------------------------------------------------------->
<!--
  Copyright 2022 Sylvain Joube & Joel Falcou
  Licensed under the terms of the Attribution-ShareAlike 4.0 International License (CC BY-SA 4.0)
-->
<!------------------------------------------------------------------------------------------------->

<meta charset="utf-8" lang="en">
<!------------------------------------------------------------------------------------------------->

**Kiwaku, containers well made**
    Generative programming for efficient HPC data structures
<small><em><span class="current-date"></span>&nbsp;REPRISES</em></small>
<br>
Sylvain JOUBE
<br>
<small>
Joël FALCOU, Hadrien GRASLAND, David CHAMONT.
</small>
<br>
<center><small>![](images/lisn.png style="height: 3rem")&nbsp;&nbsp;&nbsp;![](images/ijclab.png style="height: 3rem")</small></center>
<center>![](images/ccby40.png style="height: 0.7rem")</center>
<small><small>Powered by Markdeep and Markdeep-Slides</small></small>

---
<!------------------------------------------------------------------------------------------------->

# Intro
    Wow such title

---

## Slide 1

Pourquoi les tableau n-d on en a besoin, pourquoi c'est fondamental ?
C'est super compliqué, la preuve c'est qu'il y en a vraiment beaucoup : EIGEN, Armadillo, XTensor [(+logo)](https://github.com/xtensor-stack/xtensor), std::mdspan, blaze... [caser cette référence quelque part](https://xkcd.com/927/) (recherche google "xkcd standards"). C'est super compliqué parce que le design space est très large : owing vs non owning ; dimensions statiques vs dynamiques ; base indexes ; storage order ; ...

![](images/standards.png )

---

## Slide 1 conclusion

Conclusion du slide : 
- si on fait bêtement une implementation monolithique classique pour tous les use-case, on va forcément oublier des choses, et ça va faire un standard de plus.
- Il faut adapter une décision de design radicalement différente pour résoudre de manière efficace ce problème. C'est pas un problème bas niveau, c'est un problème fondamental de design.

L'objectif de Kiwaku et en général est de définir des outils de développement efficaces et expressifs (ça va vite et c'est lisible). 


---

## Wow so much slide

Prendre une définition de la GP + schéma : à refaire en ASCI-art mais en attendant on peut le mettre comme ça dans les slides.

![](images/DEMRAL.png)

Notre position c'est que qu'on peut utiliser la generative programming (GP) pour résoudre ce problème de design d'une manière suffisamment flexible à l'usage pour résoudre ce problème et répondre à tous les use-case.   

---

## Wow very Kiwaku

Kiwaku est censé résoudre ce problème, exemple de code qui claque.

![](images/so_much_kiwaku.jpg)

---

# Partie 1

---

## 

(1 ou 2 slides) Les problèmes avec l'état de l'art : globalement les autres solutions ne font pas tout ou sont trop compliquées pour des non experts en informatique. Insister sur le fait que la qualité de l'interface est super importante étant donné que c'est les physiciens/matheux/biologistes qui vont s'en servir. "C'est pas parce que c'est un outil informatique que ça doit être compliqué." Et l'interface ne s'adresse pas à des informaticiens, outils informatiques mais pas pour des purs informaticiens. Il faut que ce soit intuitif. "Discoverability should be high". Il faut aussi que ce soit utilisable en parcourant la doc d'une manière très superficielle.

---

## 

Là on fait un état de l'art et on montre à quel point c'est moche et pas intuitif quand on utilise ces solutions. (1 slide par solution)
- vector + PMR
- mdspan
- Eigen

Conclusion orale et on passe à la suite.

---

## 

(1 slide) Remettre le schéma `DEMRAL.pdf` en écrivant ce à quoi correspondent chaque boite.

![](images/DEMRAL.png)

---

## 

(1 slide) Liste des options (size, source, base_index, label (on ne parlera pas de stride)), et pour chaque option dire ce qui est dispo par option.

---

## 

(1 ou 2 slide.s) Faire des exemples

---

## 

Le second slide d'exemples, peut-être

---

## 

(1 slide) Mettre un IFrame Godbolt : un tableau en C et un tableau en Kiwaku, on fait une opération dessus et on montre que l'assembleur est identique (donc aussi rapide que si on l'avait codé en dur à la main)

---

# Conclusion (1 ou 2 slides)

---

## Conclusion

Qu'est-ce qu'on est en train de faire maintenant
- Allocateurs
- Slicers
- Où est-ce qu'on veut aller dans la thèse :
  - Gestion de l'hétérogénéité (localité des données par exemple ?)
  - Distribution, compatibilité GPU, interopérabilité avec des outils actuels comme SYCL. Par exemple, écrire du Kiwaku qui génère du code SYCL.

<!------------------------------------------------------------------------------------------------->

---

# Thanks for your attention !

<!------------------------------------------------------------------------------------------------->
<!-- Markdeep slides stuff -->
<script>
    markdeepSlidesOptions = {
        aspectRatio: 16 / 9,
        theme: 'lri',
        fontSize: 22,
        diagramZoom: 1.0,
        totalSlideNumber: true,
        progressBar: true,
        breakOnHeadings: false,
        slideChangeHook: (oldSlide, newSlide) => {},
        modeChangeHook: (newMode) => {}
    };
</script>
<link rel="stylesheet" href="markdeep-slides/lib/markdeep-relative-sizes/1.09/relativize.css">
<link rel="stylesheet" href="markdeep-slides/markdeep-slides.css">
<script src="markdeep-slides/markdeep-slides.js"></script>

<!-- Markdeep stuff -->
<script>
    markdeepOptions = {
        tocStyle: 'none',
        detectMath: false,
        onLoad: function() {
            initSlides();
        }
    };
</script>
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style>
<script src="markdeep-slides/lib/markdeep/1.09/markdeep.min.js" charset="utf-8"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
